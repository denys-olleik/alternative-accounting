@model Accounting.Models.ToDoViewModels.TasksPaginatedViewModel

@{
  ViewData["Title"] = "Tasks - " + ConfigurationSingleton.Instance.ApplicationName;
}

<script src="~/js/vue-3-5-13.js" asp-append-version="true"></script>

@{
  string headerText = "Tasks";
}
<partial name="_H1HeaderPartial" model="@headerText" />

<template id="todo-template">
  <div class="background-color-antiquewhite">
    <!-- Single row for the task -->
    <div class="display-flex border-bottom-1px-solid-lightgray padding-top-bottom-2px"
         :data-to-do-id="toDo.toDoID"
         draggable="true"
         @@dragstart="beginDraggingToDo($event, toDo)"
         @@dragover="onDragOver($event, toDo)"
         @@drop="performToDoDrop($event, toDo)"
         @@dragend="endDraggingToDo">

      <!-- Left: +/- toggle, title -->
      <div class="display-flex flex-1 align-items-center">
        <!-- Expand/collapse toggle exactly like Accounts -->
        <a v-if="toDo.children && toDo.children.length"
           href="#"
           class="margin-right-5px text-decoration-none"
           @@click.prevent="toggleChildren">
          <span v-if="state.childrenExpanded">-</span>
          <span v-else>+</span>
        </a>

        <a href="#"
           class="text-decoration-none"
           @@click.prevent="handleToDoClick(toDo.toDoID)">
          {{ toDo.title }}
        </a>

        <!-- Options / Information panel (visible when selected) -->
        <div v-if="state.optionsExpanded" class="display-flex flex-direction-column margin-left-5px">
          <!-- Options strip -->
          <div class="display-flex margin-bottom-2px">
            <div class="display-flex flex-direction-column background-color-333333 padding-left-5px padding-right-5px">
              <div class="flex-1"></div>
              <a class="font-size-12px font-Roboto color-white text-decoration-none cursor-default">options:</a>
              <div class="flex-1"></div>
            </div>
            <div class="display-flex flex-direction-column background-color-333333 padding-right-5px padding-left-5px margin-left-2px">
              <div class="flex-1"></div>
              <a class="font-size-16px font-Roboto color-white text-decoration-none"
                 :href="`/t/create?parentToDoId=${toDo.toDoID}`">add subtask</a>
              <div class="flex-1"></div>
            </div>
          </div>

          <!-- Information strip -->
          <div class="display-flex">
            <div class="display-flex flex-direction-column background-color-darkcyan padding-left-5px padding-right-5px">
              <div class="flex-1"></div>
              <a class="font-size-12px font-Roboto color-white text-decoration-none cursor-default">information:</a>
              <div class="flex-1"></div>
            </div>

            <!-- Assigned users -->
            <div class="display-flex flex-direction-row background-color-darkcyan padding-right-5px padding-left-5px border-radius-5px margin-left-2px">
              <div class="display-flex align-items-center">
                <span class="font-size-16px font-Roboto color-white text-decoration-none margin-right-5px">
                  Assigned:
                </span>
                <template v-if="toDo.users && toDo.users.length">
                  <a v-for="user in toDo.users"
                     :key="user.userID"
                     :href="`/u/details/${user.userID}`"
                     class="font-size-16px font-Roboto color-white text-decoration-none border-1px-solid-white border-radius-2px margin-sides-2px padding-sides-2px">
                    {{ user.firstName }} {{ user.lastName }}
                  </a>
                </template>
                <span v-else class="font-size-16px font-Roboto color-white text-decoration-none">
                  none
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Right: status (aligned right), clickable to change -->
      <div class="display-flex align-items-center">
        <to-do-status-component v-if="availableStatuses && availableStatuses.length"
                                :to-do="toDo"
                                :status="state.status"
                                :available-statuses="availableStatuses"
                                :key="toDo.toDoID"
                                @@status-changed="onStatusChanged">
        </to-do-status-component>
      </div>
    </div>

    <!-- Children -->
    <div v-if="state.childrenExpanded && toDo.children && toDo.children.length" class="margin-left-25px">
      <template v-for="child in toDo.children" :key="child.toDoID">
        <to-do :to-do="child"
               :available-statuses="availableStatuses"
               @@todo-clicked="onChildClicked"
               @@request-refresh-branch="onRequestRefreshBranch">
        </to-do>
      </template>
    </div>
  </div>
</template>

<template id="todo-status-template">
  <div>
    <a v-if="!isChangingStatus"
       :key="status"
       href="#"
       class="text-decoration-none color-white padding-sides-5px border-radius-3px"
       @@click.prevent="startChangeStatus"
       :class="getStatusClass(status)">
      {{ status }}
    </a>
    <div v-else>
      <a v-for="st in availableStatuses"
         :key="st"
         href="#"
         class="text-decoration-none color-white padding-sides-5px border-radius-3px margin-right-3px"
         @@click.prevent="changeStatus(st)"
         :class="getStatusClass(st)">
        {{ st }}
      </a>
    </div>
  </div>
</template>

<div class="display-flex margin-bottom-5px background-color-antiquewhite">
  <div class="margin-left-20px">
    <a asp-action="Create" asp-controller="Task" class="font-Roboto font-size-16px color-blue">Create task</a>
  </div>
  <div class="flex-1 text-align-right">
    <a asp-action="Index" asp-controller="Home" class="font-Roboto font-size-16px color-blue margin-left-20px">Home</a>
  </div>
</div>

<div id="app" class="display-flex flex-direction-column font-Roboto-Mono">
  <div>
    <template v-for="toDo in toDos" :key="toDo.toDoID">
      <to-do :to-do="toDo"
             :available-statuses="availableStatuses"
             @@todo-clicked="onRootClicked"
             @@request-refresh-branch="refreshBranch">
      </to-do>
    </template>
  </div>
</div>

<script>
  const { createApp } = Vue;

  const ToDoStatusComponent = {
    template: '#todo-status-template',
    props: ['toDo', 'status', 'availableStatuses'],
    data() {
      return {
        isChangingStatus: false,
        internalStatus: (this.status || '').toLowerCase()
      };
    },
    watch: {
      status(newVal) {
        this.internalStatus = (newVal || '').toLowerCase();
      }
    },
    methods: {
      getStatusClass(status) {
        const s = (status || this.internalStatus || '').toLowerCase();
        if (s === 'open') return 'background-color-red';
        if (s === 'closed') return 'background-color-black';
        if (s === 'completed') return 'background-color-green';
        return 'background-color-gray';
      },
      async changeStatus(newStatus) {
        const toDoId = this.toDo.toDoID;
        try {
          const resp = await fetch(`/api/t/update-todo-status`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ToDoId: toDoId, Status: newStatus }),
          });
          if (!resp.ok) {
            console.error('Failed to update status');
          }
          // Update immediately in UI
          this.internalStatus = (newStatus || '').toLowerCase();
          this.$emit('status-changed', { toDoId, status: this.internalStatus });
        } catch (e) {
          console.error('An error occurred updating status:', e);
        } finally {
          this.isChangingStatus = false;
        }
      },
      startChangeStatus() {
        this.isChangingStatus = true;
      },
    },
  };

  const ToDo = {
    name: 'to-do',
    template: '#todo-template',
    props: ['toDo', 'availableStatuses'],
    components: {
      'to-do-status-component': ToDoStatusComponent
    },
    data() {
      return {
        state: {
          childrenExpanded: true,
          optionsExpanded: false,
          status: (this.toDo.status || '').toLowerCase(),
        }
      };
    },
    methods: {
      toggleChildren() {
        this.state.childrenExpanded = !this.state.childrenExpanded;
      },
      handleToDoClick() {
        this.state.optionsExpanded = !this.state.optionsExpanded;
        this.$emit('todo-clicked', this.toDo.toDoID);
      },
      onStatusChanged({ toDoId, status }) {
        if (toDoId === this.toDo.toDoID) {
          this.state.status = status; // reflect immediately
        }
      },

      // Drag-and-drop handlers
      beginDraggingToDo(event, toDo) {
        this.$root.draggedToDo = toDo;
        this.$root.originalParent = this.findParentOf(toDo.toDoID, this.$root.toDos) || null;
        if (event && event.dataTransfer) {
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', String(toDo.toDoID));
        }
      },
      onDragOver(event, potentialParent) {
        event.preventDefault();
        this.$root.potentialParent = potentialParent;
      },
      async performToDoDrop(event, dropTarget) {
        event.preventDefault();

        const dragged = this.$root.draggedToDo;
        if (!dragged || !dropTarget) {
          this.endDraggingToDo();
          return;
        }

        const draggedToDoId = dragged.toDoID;
        const newParentId = dropTarget.toDoID;

        if (draggedToDoId === newParentId) {
          this.endDraggingToDo();
          return;
        }

        // Guard: prevent dropping onto a descendant to avoid cycles client-side
        if (this.isDescendant(newParentId, draggedToDoId)) {
          console.warn('Blocked dropping onto a descendant to avoid cycle.');
          this.endDraggingToDo();
          return;
        }

        const updated = await this.updateToDoParentOnServer(draggedToDoId, newParentId);

        if (updated) {
          // Remove dragged from current parent in UI
          this.removeDraggedFromUI(draggedToDoId, this.$root.toDos);
          // Refresh drop target's children from server
          await this.updateToDoChildrenFromServer(dropTarget);
          // Ensure drop target expands to show the newly added child
          if (!(dropTarget.children && dropTarget.children.length)) {
            dropTarget.children = [];
          }
          if (!this.state.childrenExpanded && dropTarget.toDoID === this.toDo.toDoID) {
            this.state.childrenExpanded = true;
          }
        }

        this.endDraggingToDo();
      },
      endDraggingToDo() {
        this.$root.draggedToDo = null;
        this.$root.potentialParent = null;
      },

      async updateToDoParentOnServer(draggedToDoId, newParentId) {
        try {
          const response = await fetch('/api/t/update-todo-parent', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ToDoId: draggedToDoId, NewParentToDoId: newParentId }),
          });

          if (!response.ok) {
            let msg = 'Unknown error updating parent';
            try {
              const data = await response.json();
              msg = data?.error || msg;
            } catch { /* ignore */ }
            console.error('Failed to update parent:', msg);
            return false;
          }
          return true;
        } catch (e) {
          console.error('Error updating parent:', e);
          return false;
        }
      },

      async updateToDoChildrenFromServer(parentToDo) {
        try {
          const childrenResponse = await fetch(`/api/t/get-todo-children/${parentToDo.toDoID}`);
          const data = await childrenResponse.json();
          parentToDo.children = data || [];
          this.$emit('request-refresh-branch', parentToDo.toDoID);
        } catch (e) {
          console.error('Failed to refresh children:', e);
        }
      },

      // Helpers
      isDescendant(potentialAncestorId, potentialDescendantId) {
        // Returns true if potentialAncestorId exists within the subtree of potentialDescendantId
        const node = this.findNodeById(potentialDescendantId, this.$root.toDos);
        if (!node) return false;

        const stack = [...(node.children || [])];
        while (stack.length) {
          const current = stack.pop();
          if (!current) continue;
          if (current.toDoID === potentialAncestorId) return true;
          if (current.children && current.children.length) {
            stack.push(...current.children);
          }
        }
        return false;
      },
      findNodeById(id, list) {
        for (const item of list) {
          if (item.toDoID === id) return item;
          if (item.children && item.children.length) {
            const found = this.findNodeById(id, item.children);
            if (found) return found;
          }
        }
        return null;
      },
      findParentOf(childId, list, parent = null) {
        for (const item of list) {
          if (item.toDoID === childId) return parent;
          if (item.children && item.children.length) {
            const maybe = this.findParentOf(childId, item.children, item);
            if (maybe) return maybe;
          }
        }
        return null;
      },
      removeDraggedFromUI(draggedId, list) {
        for (let i = 0; i < list.length; i++) {
          const item = list[i];
          if (item.toDoID === draggedId) {
            list.splice(i, 1);
            return true;
          }
          if (item.children && item.children.length) {
            const removed = this.removeDraggedFromUI(draggedId, item.children);
            if (removed) return true;
          }
        }
        return false;
      },

      onChildClicked(toDoId) {
        this.$emit('todo-clicked', toDoId);
      },
      onRequestRefreshBranch(parentId) {
        this.$emit('request-refresh-branch', parentId);
      }
    }
  };

  const app = createApp({
    components: {
      'to-do': ToDo,
      'to-do-status-component': ToDoStatusComponent
    },
    data() {
      return {
        toDos: [],
        availableStatuses: @Html.Raw(Json.Serialize(Model.AvailableStatuses ?? new List<string>())),
        draggedToDo: null,
        potentialParent: null,
        selectedToDoId: null
      };
    },
    methods: {
      async getToDos() {
        try {
          const response = await fetch('/api/t/get-todos');
          const data = await response.json();
          this.toDos = (data && data.toDos) ? data.toDos : [];
        } catch (error) {
          console.error('Failed to fetch tasks:', error);
        }
      },
      onRootClicked(toDoId) {
        this.selectedToDoId = (this.selectedToDoId === toDoId) ? null : toDoId;
      },
      async refreshBranch(parentId) {
        try {
          const parentNode = this.findNodeById(parentId, this.toDos);
          if (!parentNode) return;
          const childrenResponse = await fetch(`/api/t/get-todo-children/${parentId}`);
          const data = await childrenResponse.json();
          parentNode.children = data || [];
        } catch (e) {
          console.error('Failed to refresh branch:', e);
        }
      },
      findNodeById(id, list) {
        for (const item of list) {
          if (item.toDoID === id) return item;
          if (item.children && item.children.length) {
            const found = this.findNodeById(id, item.children);
            if (found) return found;
          }
        }
        return null;
      }
    },
    mounted() {
      this.getToDos();
    }
  });

  app.mount('#app');
</script>