@model Accounting.Models.ToDoViewModels.TasksPaginatedViewModel

@{
  ViewData["Title"] = "Tasks - " + ConfigurationSingleton.Instance.ApplicationName;
}

<script src="~/js/vue-3-5-13.js" asp-append-version="true"></script>

@{
  string headerText = "Tasks";
}
<partial name="_H1HeaderPartial" model="@headerText" />

<template id="todo-template">
  <div class="background-color-antiquewhite">
    <div class="display-flex border-bottom-1px-solid-lightgray padding-top-bottom-2px"
         :data-to-do-id="toDo.toDoID"
         draggable="true"
         @@dragstart="beginDraggingToDo($event, toDo)"
         @@dragover="onDragOver($event, toDo)"
         @@drop="performToDoDrop($event, toDo)"
         @@dragend="endDraggingToDo">

      <!-- Left: +/- toggle, title -->
      <div class="display-flex flex-1 align-items-center">
        <a v-if="toDo.children && toDo.children.length"
           href="#"
           class="margin-right-5px text-decoration-none"
           @@click.prevent="toggleChildren">
          <span v-if="childrenExpanded">-</span>
          <span v-else>+</span>
        </a>

        <a href="#"
           class="text-decoration-none"
           @@click.prevent="handleToDoClick(toDo.toDoID)">
          {{ toDo.title }}
        </a>

        <!-- Options / Information panel (visible when this node is the globally selected one) -->
        <div v-if="optionsExpanded" class="display-flex flex-direction-column margin-left-5px">
          <!-- Options strip -->
          <div class="display-flex margin-bottom-2px">
            <div class="display-flex flex-direction-column background-color-333333 padding-left-5px padding-right-5px">
              <div class="flex-1"></div>
              <a class="font-size-12px font-Roboto color-white text-decoration-none cursor-default">options:</a>
              <div class="flex-1"></div>
            </div>
            <div class="display-flex flex-direction-column background-color-333333 padding-right-5px padding-left-5px margin-left-2px">
              <div class="flex-1"></div>
              <a class="font-size-16px font-Roboto color-white text-decoration-none"
                 :href="`/t/create?parentToDoId=${toDo.toDoID}`">add subtask</a>
              <div class="flex-1"></div>
            </div>
          </div>

          <!-- Assignees strip -->
          <div class="display-flex">
            <div class="display-flex flex-direction-column background-color-darkcyan padding-left-5px padding-right-5px">
              <div class="flex-1"></div>
              <a class="font-size-12px font-Roboto color-white text-decoration-none cursor-default">assignees:</a>
              <div class="flex-1"></div>
            </div>

            <!-- Assignees list -->
            <div class="display-flex flex-direction-row margin-left-2px">
              <div class="display-flex">
                <template v-if="toDo.users && toDo.users.length">
                  <a v-for="user in toDo.users"
                     :key="user.userID"
                     :href="`/u/details/${user.userID}`"
                     class="font-size-16px font-Roboto color-white background-color-darkcyan text-decoration-none border-radius-5px border-1px-solid-white margin-sides-2px padding-sides-5px padding-top-bottom-1px">
                    {{ user.firstName }} {{ user.lastName }}
                  </a>
                </template>
                <span v-else class="font-size-16px font-Roboto color-white text-decoration-none">
                  none
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Right: status -->
      <div class="display-flex">
        <to-do-status-component v-if="availableStatuses && availableStatuses.length"
                                :to-do="toDo"
                                :status="statusLower"
                                :available-statuses="availableStatuses"
                                :key="toDo.toDoID"
                                @@status-changed="onStatusChanged">
        </to-do-status-component>
      </div>
    </div>

    <!-- Children -->
    <div v-if="childrenExpanded && toDo.children && toDo.children.length" class="margin-left-25px">
      <template v-for="child in toDo.children" :key="child.toDoID">
        <to-do :to-do="child"
               :available-statuses="availableStatuses"
               :selected-id="selectedId"
               :expanded-path="expandedPath"
               @@todo-clicked="forwardClicked"
               @@request-refresh-branch="forwardRefresh">
        </to-do>
      </template>
    </div>
  </div>
</template>

<template id="todo-status-template">
  <div>
    <a v-if="!isChangingStatus"
       :key="status"
       href="#"
       class="text-decoration-none color-white padding-sides-5px border-radius-3px"
       @@click.prevent="startChangeStatus"
       :class="getStatusClass(status)">
      {{ status }}
    </a>
    <div v-else>
      <a v-for="st in availableStatuses"
         :key="st"
         href="#"
         class="text-decoration-none color-white padding-sides-5px border-radius-3px margin-right-3px"
         @@click.prevent="changeStatus(st)"
         :class="getStatusClass(st)">
        {{ st }}
      </a>
    </div>
  </div>
</template>

<div class="display-flex margin-bottom-5px background-color-antiquewhite">
  <div class="margin-left-20px">
    <a asp-action="Create" asp-controller="Task" class="font-Roboto font-size-16px color-blue">Create task</a>
  </div>
  <div class="flex-1 text-align-right">
    <a asp-action="Index" asp-controller="Home" class="font-Roboto font-size-16px color-blue margin-left-20px">Home</a>
  </div>
</div>

<div id="app" class="display-flex flex-direction-column font-Roboto-Mono">
  <div>
    <template v-for="toDo in toDos" :key="toDo.toDoID">
      <to-do :to-do="toDo"
             :available-statuses="availableStatuses"
             :selected-id="selectedToDoId"
             :expanded-path="expandedPath"
             @@todo-clicked="onNodeClicked"
             @@request-refresh-branch="refreshBranch">
      </to-do>
    </template>
  </div>
</div>

<script>
  const { createApp } = Vue;

  const ToDoStatusComponent = {
    template: '#todo-status-template',
    props: ['toDo', 'status', 'availableStatuses'],
    data() {
      return {
        isChangingStatus: false,
        internalStatus: (this.status || '').toLowerCase()
      };
    },
    watch: {
      status(newVal) {
        this.internalStatus = (newVal || '').toLowerCase();
      }
    },
    methods: {
      getStatusClass(status) {
        const s = (status || this.internalStatus || '').toLowerCase();
        if (s === 'open') return 'background-color-red';
        if (s === 'closed') return 'background-color-black';
        if (s === 'completed') return 'background-color-green';
        return 'background-color-gray';
      },
      async changeStatus(newStatus) {
        const toDoId = this.toDo.toDoID;
        try {
          const resp = await fetch(`/api/t/update-todo-status`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ToDoId: toDoId, Status: newStatus }),
          });
          if (!resp.ok) {
            console.error('Failed to update status');
          }
          this.internalStatus = (newStatus || '').toLowerCase();
          this.$emit('status-changed', { toDoId, status: this.internalStatus });
        } catch (e) {
          console.error('An error occurred updating status:', e);
        } finally {
          this.isChangingStatus = false;
        }
      },
      startChangeStatus() {
        this.isChangingStatus = true;
      },
    },
  };

  const ToDo = {
    name: 'to-do',
    template: '#todo-template',
    props: ['toDo', 'availableStatuses', 'selectedId', 'expandedPath'],
    components: {
      'to-do-status-component': ToDoStatusComponent
    },
    data() {
      return {
        localChildrenExpanded: false // default collapsed for every node
      };
    },
    computed: {
      // Determine if this node should show options/info (selected)
      optionsExpanded() {
        return this.selectedId === this.toDo.toDoID;
      },
      // Determine children expansion:
      // - expanded if this.toDo is in the expanded path (ancestors of selection) OR local toggle says expanded
      // - root-level collapse rule handled at root by setting expandedPath accordingly
      childrenExpanded() {
        const inPath = Array.isArray(this.expandedPath) && this.expandedPath.includes(this.toDo.toDoID);
        return inPath || this.localChildrenExpanded;
      },
      statusLower() {
        return (this.toDo.status || '').toLowerCase();
      }
    },
    methods: {
      // Clicking the title selects this node. Root will compute expandedPath so that only ancestors
      // of the selected node expand and all others collapse; clicking the same selected node again
      // collapses everything to roots-only (no expandedPath).
      handleToDoClick() {
        this.$emit('todo-clicked', this.toDo.toDoID);
      },
      // +/- toggle only affects this node's local collapsed state when it's present in expandedPath.
      // If the node is in expandedPath, user can manually collapse/expand it; if not in path and user expands it,
      // it will expand its children locally until selection changes.
      toggleChildren() {
        this.localChildrenExpanded = !this.localChildrenExpanded;
      },

      onStatusChanged({ toDoId, status }) {
        if (toDoId === this.toDo.toDoID) {
          this.toDo.status = status;
        }
      },

      // Drag-and-drop
      beginDraggingToDo(event, toDo) {
        this.$root.draggedToDo = toDo;
        this.$root.originalParent = this.findParentOf(toDo.toDoID, this.$root.toDos) || null;
        if (event && event.dataTransfer) {
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', String(toDo.toDoID));
        }
      },
      onDragOver(event, potentialParent) {
        event.preventDefault();
        this.$root.potentialParent = potentialParent;
      },
      async performToDoDrop(event, dropTarget) {
        event.preventDefault();

        const dragged = this.$root.draggedToDo;
        if (!dragged || !dropTarget) {
          this.endDraggingToDo();
          return;
        }

        const draggedToDoId = dragged.toDoID;
        const newParentId = dropTarget.toDoID;

        if (draggedToDoId === newParentId) {
          this.endDraggingToDo();
          return;
        }

        if (this.isDescendant(newParentId, draggedToDoId)) {
          console.warn('Blocked dropping onto a descendant to avoid cycle.');
          this.endDraggingToDo();
          return;
        }

        const updated = await this.updateToDoParentOnServer(draggedToDoId, newParentId);

        if (updated) {
          this.removeDraggedFromUI(draggedToDoId, this.$root.toDos);
          await this.updateToDoChildrenFromServer(dropTarget);
          // Ensure the drop target shows its children after successful drop
          this.localChildrenExpanded = true;
        }

        this.endDraggingToDo();
      },
      endDraggingToDo() {
        this.$root.draggedToDo = null;
        this.$root.potentialParent = null;
      },
      async updateToDoParentOnServer(draggedToDoId, newParentId) {
        try {
          const response = await fetch('/api/t/update-todo-parent', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ToDoId: draggedToDoId, NewParentToDoId: newParentId }),
          });

          if (!response.ok) {
            let msg = 'Unknown error updating parent';
            try {
              const data = await response.json();
              msg = data?.error || msg;
            } catch {}
            console.error('Failed to update parent:', msg);
            return false;
          }
          return true;
        } catch (e) {
          console.error('Error updating parent:', e);
          return false;
        }
      },
      async updateToDoChildrenFromServer(parentToDo) {
        try {
          const childrenResponse = await fetch(`/api/t/get-todo-children/${parentToDo.toDoID}`);
          const data = await childrenResponse.json();
          parentToDo.children = data || [];
          this.$emit('request-refresh-branch', parentToDo.toDoID);
        } catch (e) {
          console.error('Failed to refresh children:', e);
        }
      },

      // Utilities
      isDescendant(potentialAncestorId, potentialDescendantId) {
        const node = this.findNodeById(potentialDescendantId, this.$root.toDos);
        if (!node) return false;
        const stack = [...(node.children || [])];
        while (stack.length) {
          const current = stack.pop();
          if (!current) continue;
          if (current.toDoID === potentialAncestorId) return true;
          if (current.children && current.children.length) {
            stack.push(...current.children);
          }
        }
        return false;
      },
      findNodeById(id, list) {
        for (const item of list) {
          if (item.toDoID === id) return item;
          if (item.children && item.children.length) {
            const found = this.findNodeById(id, item.children);
            if (found) return found;
          }
        }
        return null;
      },
      findParentOf(childId, list, parent = null) {
        for (const item of list) {
          if (item.toDoID === childId) return parent;
          if (item.children && item.children.length) {
            const maybe = this.findParentOf(childId, item.children, item);
            if (maybe) return maybe;
          }
        }
        return null;
      },
      removeDraggedFromUI(draggedId, list) {
        for (let i = 0; i < list.length; i++) {
          const item = list[i];
          if (item.toDoID === draggedId) {
            list.splice(i, 1);
            return true;
          }
          if (item.children && item.children.length) {
            const removed = this.removeDraggedFromUI(draggedId, item.children);
            if (removed) return true;
          }
        }
        return false;
      },

      // Bubble events upward
      forwardClicked(id) {
        this.$emit('todo-clicked', id);
      },
      forwardRefresh(parentId) {
        this.$emit('request-refresh-branch', parentId);
      }
    }
  };

  const app = createApp({
    components: {
      'to-do': ToDo,
      'to-do-status-component': ToDoStatusComponent
    },
    data() {
      return {
        toDos: [],
        availableStatuses: @Html.Raw(Json.Serialize(Model.AvailableStatuses ?? new List<string>())),
        draggedToDo: null,
        potentialParent: null,
        selectedToDoId: null,   // which task has options/information expanded
        expandedPath: []        // array of IDs from root to selected to auto-expand ancestors
      };
    },
    methods: {
      async getToDos() {
        try {
          const response = await fetch('/api/t/get-todos');
          const data = await response.json();
          this.toDos = (data && data.toDos) ? data.toDos : [];
          // Ensure initial state: everything collapsed, nothing selected
          this.selectedToDoId = null;
          this.expandedPath = [];
        } catch (error) {
          console.error('Failed to fetch tasks:', error);
        }
      },

      // Handle clicks to enforce "only one expanded at a time" and root-only collapse on second click
      onNodeClicked(clickedId) {
        if (this.selectedToDoId === clickedId) {
          // Clicking the currently selected node collapses to roots only
          this.selectedToDoId = null;
          this.expandedPath = [];
          return;
        }

        // Select new node and compute ancestors path to expand only along that path
        this.selectedToDoId = clickedId;
        this.expandedPath = this.computeAncestorPath(clickedId);
      },

      computeAncestorPath(targetId) {
        // Returns an array of IDs from root down to the parent(s) of the target, including the target
        const path = [];
        const found = this.findPathDFS(this.toDos, targetId, path);
        return found ? path : [];
      },

      // Depth-first search to build path list [root...target]
      findPathDFS(nodes, targetId, path) {
        for (const n of nodes) {
          path.push(n.toDoID);
          if (n.toDoID === targetId) {
            return true;
          }
          if (n.children && n.children.length) {
            if (this.findPathDFS(n.children, targetId, path)) {
              return true;
            }
          }
          path.pop();
        }
        return false;
      },

      async refreshBranch(parentId) {
        try {
          const parentNode = this.findNodeById(parentId, this.toDos);
          if (!parentNode) return;
          const childrenResponse = await fetch(`/api/t/get-todo-children/${parentId}`);
          const data = await childrenResponse.json();
          parentNode.children = data || [];
        } catch (e) {
          console.error('Failed to refresh branch:', e);
        }
      },

      findNodeById(id, list) {
        for (const item of list) {
          if (item.toDoID === id) return item;
          if (item.children && item.children.length) {
            const found = this.findNodeById(id, item.children);
            if (found) return found;
          }
        }
        return null;
      }
    },
    mounted() {
      this.getToDos();
    }
  });

  app.mount('#app');
</script>